import torch
import numpy as np
from datetime import datetime
import os
import argparse
import json
import pickle as pkl
from multiprocessing import Pool

from torch_model import graphnn
from utils_loss import graph
from func2vec import func2vec
from utils import *


parser = argparse.ArgumentParser()
parser.add_argument('--device', type=str, default='0',
                    help='visible gpu device')
parser.add_argument('--gap', type=str, default='0.5',
                    help='triple loss gap')
parser.add_argument('--fea_dim', type=int, default=7,
                    help='feature dimension')
parser.add_argument('--fedora_js', type=str, default='../data/CoreFedoraFeatureJson0505',
                    help='feature json of fedora packages')
parser.add_argument('--valid_pairs', type=str, default='../data/validation_pairs/valid_pairs_v1/76_fea_dim',
                    help='valid pair json')

parser.add_argument('--load_path', type=str, default='../data/7fea_contra_torch_b128/saved_model/model-inter-best.pt',
                    help='path for model loading, "#LATEST#" for the latest checkpoint')
parser.add_argument('--save_path', type=str,
                    default='../data/core_funcs', help='path for pkl saving')
parser.add_argument('--valid_save_path', type=str,
                    default='../data/76fea_triple_torch_epo150_gap0.5/valid_pairs', help='path for pkl saving')


def core_fedora_embedding(prefix, norm):
    print("start process with prefix: ", prefix)
    args = parser.parse_args()
    print("=================================")
    print(args)
    print("=================================")

    # all features extracted from core fedora packages. this dir is generated by unzipping coreFedoraFeatureZip
    FEATURE_JSON_CORE_FEDORA = args.fedora_js
    if not os.path.exists(args.save_path):
        os.makedirs(args.save_path)
    core_fedora_fedora_model_7fea = args.save_path + \
        '/core_funcs_{0}.pkl'.format(str(prefix))
    # Model
    # os.environ["CUDA_VISIBLE_DEVICES"] = args.device
    gpu = prefix % 4
    os.environ["CUDA_VISIBLE_DEVICES"] = str(gpu)
    LOAD_PATH = args.load_path
    level_ids = os.listdir(FEATURE_JSON_CORE_FEDORA)

    model = func2vec(LOAD_PATH, True, args.fea_dim)

    func_vectors = {}
    count = 0
    package_count = 0
    for first_level_id in level_ids:
        if not first_level_id.startswith(str(prefix)):
            continue
        for second_level_id in level_ids:
            second_level_path = os.path.join(
                FEATURE_JSON_CORE_FEDORA, first_level_id, second_level_id)
            if not os.path.exists(second_level_path):
                continue
            packages = os.listdir(second_level_path)
            for package in packages:
                package_count += 1
                if package_count % 100 == 0:
                    print("package: ", package_count, "----", prefix)
                package_path = os.path.join(second_level_path, package)
                if not os.path.isdir(package_path):
                    continue
                package_feature_json = os.path.join(
                    package_path, package+'.json')
                if not os.path.exists(package_feature_json):
                    continue
                try:
                    with open(package_feature_json, 'r') as load_f:
                        content = json.load(load_f)
                except:
                    print("error package", package)
                    continue

                for binary_file in content:
                    if 'binFileFeature' not in binary_file:
                        continue
                    for func in binary_file['binFileFeature']['functions']:
                        if func['nodes'] < 5:
                            continue
                        if func['isThunkFunction'] is True or 'text' not in func['memoryBlock']:
                            continue
                        key = (
                            package, binary_file['formattedFileName'], func['entryPoint'])
                        # key2func[key] = func
                        vec = model.get_embedding_from_func_fea(
                            func, correct_edges=True)
                        vec = vec.cpu().detach().numpy()
                        if norm:
                            vec = norm_vec(vec)
                        func_vectors[key] = vec
                        count += 1
                        if count % 10000 == 0:
                            print(count, "----", prefix)

                # key2func = {}
                # keys = list(key2func.keys())
                # st = 0
                # batch = 128
                # while(st < len(keys)):
                #     if st+batch > len(keys):
                #         end = len(keys)
                #     else:
                #         end = st + batch
                #     func_fea_l = []
                #     for i in range(st, end):
                #         func_fea_l.append(key2func[keys[i]])

                #     vecs = model.get_embeddings_from_func_fea_l(func_fea_l, correct_edges=True, func_sig=None)
                #     vecs = vecs.cpu().detach().numpy()
                #     # vecs = vecs.detach().numpy()
                #     for i in range(st, end):
                #         if norm:
                #             vec = norm_vec(vecs[i-st])
                #         else:
                #             vec = vecs[i-st]
                #         func_vectors[keys[i]] = vec
                #     count += end-st+1
                #     st = end
                # print("count: ", count, "----", prefix)
                        
    print("func nums : ", len(func_vectors), "----", prefix)

    with open(core_fedora_fedora_model_7fea, 'wb') as fo:
        pkl.dump(func_vectors, fo)


def get_true_pairs(js_path):
    true_pairs = []
    with open(js_path) as load_f:
        for line in load_f:
            pair = json.loads(line.strip())
            true_pairs.append(pair)
    return true_pairs


def save_data(data, save_path):
    for item in data:
        with open(save_path, 'a+') as f:
            line = json.dumps(item)
            f.write(line+'\n')


def valid_embedding_pairs(norm):
    args = parser.parse_args()
    print("=================================")
    print(args)
    print("=================================")

    valid_pairs_7fea = args.valid_pairs
    valid_vec_pairs_dir = args.valid_save_path
    if not os.path.exists(args.valid_save_path):
        os.makedirs(args.valid_save_path)
    os.environ["CUDA_VISIBLE_DEVICES"] = args.device
    LOAD_PATH = args.load_path

    # Model
    model = func2vec(LOAD_PATH, True, args.fea_dim)

    count = 0
    js_files_7fea = os.listdir(valid_pairs_7fea)
    for js_file in js_files_7fea:
        print('start to process:', js_file)
        valid_vec_pairs = []
        pairs_7_fea_js = os.path.join(valid_pairs_7fea, js_file)
        true_pairs_7_fea = get_true_pairs(pairs_7_fea_js)
        for pair in true_pairs_7_fea:
            count += 1
            if count % 10000 == 0:
                print(count)
            key = pair[0]['fname']
            l_graph = model.get_graph(pair[0])
            l_vec = model.get_embedding_from_func_graph(l_graph)
            l_vec = l_vec.cpu().detach().numpy()
            if norm:
                l_vec = norm_vec(l_vec)
            r_graph = model.get_graph(pair[1])
            r_vec = model.get_embedding_from_func_graph(r_graph)
            r_vec = r_vec.cpu().detach().numpy()
            if norm:
                r_vec = norm_vec(r_vec)
            valid_vec_pairs.append({key: [l_vec, r_vec]})
        true_vec_pairs_7_fea_js = os.path.join(
            valid_vec_pairs_dir, js_file.replace('.json', '.pkl'))
        with open(true_vec_pairs_7_fea_js, 'wb') as fo:
            pkl.dump(valid_vec_pairs, fo)


def generate_vec_index(data_path, id2key_save_path, id2vec_save_path, norm):
    raw_data_files = os.listdir(data_path)
    raw_data = {}
    for f in raw_data_files:
        with open(os.path.join(data_path, f), 'rb') as load_f:
            raw_data.update(pkl.load(load_f))
    id = 0
    id2key = {}
    id2vec = {}
    for key in raw_data:
        id += 1
        if id % 100000 == 0:
            print(id)
        id2key[id] = key
        if norm:
            id2vec[id] = norm_vec(raw_data[key])
        else:
            id2vec[id] = raw_data[key]
    print(id)
    save_pkl(id2key, id2key_save_path)
    save_pkl(id2vec, id2vec_save_path)


def vec_index_all_fedora(data_path, prefix, index_save_path, norm):
    file_path = os.path.join(data_path, 'core_funcs_{0}.pkl'.format(prefix))
    with open(file_path, 'rb') as load_f:
        content = pkl.load(load_f)
    if len(content) > 100000000:
        print('error, more than 100000000 functions')
    id = 100000000 * prefix
    id2key = {}
    id2vec = {}
    for key in content:
        id+=1
        if id % 1000000 == 0:
            print(id, '----', prefix)
        id2key[id] = key
        if norm:
            id2vec[id] = norm_vec(content[key])
        else:
            id2vec[id] = content[key]

    id2key_save_path = os.path.join(index_save_path, 'id2key_{0}.pkl'.format(prefix))
    id2vec_save_path = os.path.join(index_save_path, 'id2vec_{0}.pkl'.format(prefix))
    save_pkl(id2key, id2key_save_path)
    save_pkl(id2vec, id2vec_save_path)
    





if __name__ == "__main__":
    with Pool(10) as p:
        p.starmap(core_fedora_embedding, [(i, True) for i in range(10)])
    print("core func embedding done")

    # valid_embedding_pairs(True)
